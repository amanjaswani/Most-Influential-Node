# -*- coding: utf-8 -*-
"""enron_small.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xFqCU0hTFCgZGhONdeXeJCasLvXnDJdz
"""

from google.colab import drive
drive.mount('/content/drive')

!ls "/content/drive/My Drive/Game Theory Most Influential Nodes/dataset/"

data_path = "/content/drive/My Drive/Game Theory Most Influential Nodes/dataset/"

import csv
import networkx as nx
import matplotlib.pyplot as plt
import sys
import random
import scipy.stats as st
import math

"""# **Node Info**"""

node_info = {}
f = csv.reader(open(data_path+"email-Enron-node-labels.csv","r"))
for row in f:
  row = row[0].split(" ")
  node_info[int(row[0])]=row[1]

# node_info

"""# **Graph Creation (for games 1 and 2)**"""

G = nx.Graph()

for i in range(1, 149):   # range = number of nodes
    G.add_node(i)

f = csv.reader(open(data_path+"email-Enron-proj-graph.csv","r"))
for row in f:
  row = row[0].split(" ")
  G.add_edge(int(row[0]),int(row[1]))


print (len(G.nodes))
print (len(G.edges))

"""# **Game 1**"""

shapley_values = {}

for v in G:
  shapley_values[v] = 1.0/(1+G.degree(v))
  neighbours = [n for n in G.neighbors(v)]

  for u in neighbours:
    shapley_values[v] += 1.0/(1+G.degree(u))

sorted_shapley_values = sorted(shapley_values.items(), key=lambda kv: kv[1], reverse=True)

most_influential_node = sorted_shapley_values[0]
top_ten = sorted_shapley_values[0:10]

for tuple in top_ten:
    print (tuple[0], node_info[tuple[0]])

"""# **Game 2**"""

shapley_values = {}
k=5

for v in G:
  shapley_values[v] = min(1, 1.0*k/(1+G.degree(v)))
  neighbours = [n for n in G.neighbors(v)]

  for u in neighbours:
    shapley_values[v] += max(0, 1.0*(G.degree(u)-k+1)/(G.degree(u)*(1+G.degree(u))))

sorted_shapley_values = sorted(shapley_values.items(), key=lambda kv: kv[1], reverse=True)
most_influential_node = sorted_shapley_values[0]
top_ten = sorted_shapley_values[0:10]

for tuple in top_ten:
    print (tuple[0], node_info[tuple[0]])

"""# **Graph Creation (for the remaining games)**"""

G = nx.Graph()

f = csv.reader(open(data_path+"email-Enron-proj-graph.csv","r"))

for i in range(1, 149): 
    G.add_node(i)

for row in f:
    row = row[0].split(" ")
    G.add_edge(int(row[0]), int(row[1]), weight = float(row[2]))

print (len(G.nodes))
print (len(G.edges))

no_of_nodes = len(G.nodes)

extended_neighbours = {str(key):[] for key in range(1, no_of_nodes+1)}
extended_degrees = {str(key):0 for key in range(1, no_of_nodes+1)}
cutoff_distance = 2


for v in G:
    for u in G:
        if u==v or nx.has_path(G, v, u)==False:
            continue
        if nx.shortest_path_length(G, v, u)<=cutoff_distance:
            extended_neighbours[str(v)].append(u)
            extended_degrees[str(v)] += 1
       
    
shapley_values = {}

for v in G:
    shapley_values[v] = 1.0/(1+extended_degrees[str(v)])

    for u in extended_neighbours[str(v)]:
        shapley_values[v] += 1.0/(1+extended_degrees[str(u)])

sorted_shapley_values = sorted(shapley_values.items(), key=lambda kv: kv[1], reverse=True)
most_influential_node = sorted_shapley_values[0]
top_ten = sorted_shapley_values[0:10]

for tuple in top_ten:
    print (tuple[0], node_info[tuple[0]])

"""# **Game 4**"""

def f(x):
    return 100-x

shapley_values = {str(key):0 for key in range(1, no_of_nodes+1)}

for v in G:
    distances = {str(key):0 for key in range(1, no_of_nodes+1)}

    for i in range(1, no_of_nodes+1):
        if nx.has_path(G, v, i):
            distances[str(i)] = nx.shortest_path_length(G, v, i)
        else:
            distances[str(i)]=999999

    del distances[str(v)]
    distance_vector = sorted(distances.items(), key=lambda kv: kv[1])

    sum = 0
    index = no_of_nodes-1
    prevDistance = -1
    currSV = -1

    while index>0:
        if distance_vector[index-1][1] == prevDistance:
            currSV = prevSV
        else:
            currSV = f(distance_vector[index-1][1])/(1+index) - sum

        shapley_values[distance_vector[index-1][0]] += currSV
        sum += f(distance_vector[index-1][1])/(index*(1+index))
        prevDistance = distance_vector[index-1][1]
        prevSV = currSV
        index -= 1

    shapley_values[str(v)] += f(0) - sum

sorted_shapley_values = sorted(shapley_values.items(), key=lambda kv: kv[1], reverse=True)
most_influential_node = sorted_shapley_values[0]
top_ten = sorted_shapley_values[0:10]

for tuple in top_ten:
    print (int(tuple[0]), node_info[int(tuple[0])])

"""# **Game 5**"""

cutoff_weights = {key:random.uniform(0, 5) for key in range(1, no_of_nodes+1)}

alpha = {key:0 for key in range(1, no_of_nodes+1)}
beta = {key:0 for key in range(1, no_of_nodes+1)}

for v in G:
    neighbours = [n for n in G.neighbors(v)]
    for u in neighbours:
        alpha[v] += G[v][u]['weight']
        beta[v] += G[v][u]['weight']**2

shapley_values = {key:0 for key in range(1, no_of_nodes+1)}

for v in G:
    if G.degree(v)<=1:
        continue

    for m in range(0, G.degree(v)+1):
        mean1 = m*alpha[v]/(G.degree(v))
        variance_1 = (m*G.degree(v)/(G.degree(v)*(G.degree(v)-1)))*(beta[v]-(alpha[v]**2/G.degree(v)))

        if variance_1==0.0:
            p=0
        else:
            p = st.norm.cdf((cutoff_weights[v]-mean1)/math.sqrt(variance_1))

        shapley_values[v] += p/(1+G.degree(v))

    neighbours = [n for n in G.neighbors(v)]
    for u in neighbours:
        if G.degree(u)<=2:
            continue

        p = 0
        for m in range(0, G.degree(u)):
            if (G.has_edge(v, u)):
                w_uv = G[v][u]['weight']
            else:
                w_uv = 0

            mean2 = (m*1.0/(G.degree(u)-1))*(alpha[u]-w_uv)
            variance_2 = (1.0*m*(G.degree(u)-1-m)/((G.degree(u)-1)*(G.degree(u)-2)))*(beta[u]-math.pow(w_uv, 2)-(math.pow(alpha[u]-w_uv, 2)/(G.degree(u)-1)))

            if variance_2 == 0.0:
                Zij = 0
            else:
                Zij = 0.5*(math.erf((cutoff_weights[u]-mean2)/(math.sqrt(2*variance_2))) - math.erf((cutoff_weights[u]-w_uv-mean2)/(math.sqrt(2*variance_2))))

            p += Zij*((G.degree(u)-m)/(G.degree(u)*(G.degree(u)+1)))

        shapley_values[v] += p

sorted_shapley_values = sorted(shapley_values.items(), key=lambda kv: kv[1], reverse=True)
most_influential_node = sorted_shapley_values[0]
top_ten = sorted_shapley_values[0:10]

for tuple in top_ten:
    print (int(tuple[0]), node_info[int(tuple[0])])

